{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"app/cli/","text":"","title":"Cli"},{"location":"app/config/","text":"","title":"Config"},{"location":"app/internal/","text":"101: TECHINICAL How works a hierarchical data lookup? Query a key Can be a simple string or complex data Can be anything in json compatible Albero will resolve query in 2 parts: It will first look in different locations the key. It is usually files, but it can also be an url or anything. The queried data must be a valid json data type (TOFIX: So it works also for yaml, toml .... it supports anyconfig ) Example: The path strategy will allow you to target Then it will process all results and load a strategy to resolve which results to keep. Example: The last strategy consists in keeping always the last result while the merge strategy consists in merging inteligentelly data. This is quite useful for dict or lists. Lookup data in a tree of files Goes sequentially according the backends list Backend/Engine list is modular Engine Plugin: Jerakia/HIera/Ansible/Curl Backend Plugin: loop/hier All result are returned, and then the rules are applied Rules match to a key and apply a strategy (essentially determine if and how the different value are merged or replaced). It can also apply filter to the result and modify its content (future). This is modular Strategy: last/schema Last will always take the last found value, whatever what it previously found. schema schema: It will take into account the strucutre of the data and try to merge them intelligentelly. See more on schema Then it returns the result Use cases Ansible integration Generic SOT Rest API (Future) More !!!!","title":"Internal"},{"location":"guide/","text":"105: Integrations Integration in Ansible Integration as a web server (future) webserver Integration with Puppet Integration with Foreman","title":"Index"},{"location":"guide/best_practices/","text":"104: Best practices Going into IaC Use git to track your tree D.R.Y. Things are quite easily moving Code structure Profile and Class Role and profiles key lookup Hierarchies Foreman Use environnements, site, locatation ... Common keys vs dedicated keys The profile key, default placeholder The resource modele It's like a puppet resource, a catalog of items to apply It's possible to use this model with ansible, and it change radically the way Ansible can be used then. See integration. Debugging Use the explain mode And trace mode Use GNU tools tree grep -Rw . git status -sb With ansible. Use a strict naming scheme, apply your Ansible usual name schema into Albero You can put some jinja variable into Albero, Ansible will be able to replace and understand them during the runtime Dynamic inventories and ENC Apply products Apply roles/profiles pattern Use resource based roles => See my collection, it just works","title":"Best practices"},{"location":"guide/ansible/","text":"Topics: 1) Apply role/profile pattern * Mission: We want to apply to profile/class pattern to ansible inventories and playbooks. * Always use dynamic inventories * Static inventories are for shorthand aliases * Design a simple tree * Take advantages of this to generate dynamic ansible groups * Use composed plugin * THe power of ansible-tree * Assign playbooks to specific roles","title":"Index"},{"location":"learn/101/","text":"100: KEEPE IT SIMPLEME How works a hierarchical data lookup? Query a key Albero is composed of 2 parts: It will first look in different locations the key. It is usually files, but it can also be an url or anything. Lookup data in a tree of files Goes sequentially according the backends list Backend/Engine list is modular Engine Plugin: Jerakia/HIera/Ansible/Curl Backend Plugin: loop/hier All result are returned, and then the rules are applied Rules match to a key and apply a strategy (essentially determine if and how the different value are merged or replaced). It can also apply filter to the result and modify its content (future). This is modular Strategy: last/schema Last will always take the last found value, whatever what it previously found. schema schema: It will take into account the strucutre of the data and try to merge them intelligentelly. See more on schema Then it returns the result","title":"101"},{"location":"learn/102/","text":"102: Merging data Query on items/dicts With merge strategy Query on arrays/lists It appends, replace or what ? Query other types Query without key (!) Not the actual result, schema are not sub applied BUG: TO Fix ? Performance issue ? 103: Scoped queries Add scoped variables Add variables to trees Use loops Use hierarchies, for hostgroups Use includes for other files (Future)","title":"102"}]}